/**
 * CASH - The C Again SHell
 *
 * Copyright (C) 2007 Matheus Borges Teixeira <matheus.bt at gmail.com>
 * Copyright (C) 2007 RenÃª de Souza Pinto <rene at renesp.com.br>
 * Copyright (C) 2007 Thiago Camargo Fernandes <thiagocf at grad.icmc.usp.br>
 *
 * about_errors.c
 *
 * This file is part of CASH, CASH is The C Again SHell.
 *
 * CASH is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CASH is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "cparser.h"

extern int line; /* Line counter */

int given_conversions_count = 0; /* Counter for conversion names */
int given_zeros_count = 0; /* Counter for zero names */

/**
 * Adds a new variable to the linked list.
 *
 * @author Matheus Borges Teixeira
 * @param newone - variable to be added
 */
void insert_variable(data * newone){
	datalist * temporary;
	temporary = (datalist*)malloc(sizeof(datalist));
	 
	temporary -> variable = newone;
	temporary -> next = beginning;
	beginning = temporary;
	 
	return;
}

/**
 * Performs a linear search in the variable linked list.
 * Before retrieving the variable it fetches its latest value.
 * If the variable cannot be found, it is created as an integer.
 *
 * @author Matheus Borges Teixeira
 * @param name - name of the variable requested
 * @return variable requested (either new or found)
 */
data * get_variable(char * name){
	datalist * node = beginning;
	data * new_needed = NULL;
	data * temporary = NULL;
	
	while(node != NULL){
		temporary = node -> variable;
		if(strcmp(name,temporary -> name) == 0){
			if(temporary -> isExtern){
				refresh_extern(temporary);			 
			}
			#ifdef __DEBUG__MODE__
			printf("Got variable %s\n",temporary -> name);
			#endif
			return temporary;
		}
		node = node -> next;
	}
	
	new_needed = (data*)malloc(sizeof(data));

	new_needed -> name = (char*)malloc((strlen(name)+1)*sizeof(char));
	strcpy(new_needed -> name,name);
	new_needed -> type = TYPEINT;
	new_needed -> isExtern = check_extern(name);
	new_needed -> content = malloc(sizeof(DECLAREINT));
	*(DECLAREINT*)(new_needed -> content) = 0;

	insert_variable(new_needed);
	#ifdef __DEBUG__MODE__
	printf("Created variable %s\n",new_needed -> name);
	#endif
	return new_needed;
}

/**
 * Releases the memory of a variable if generated by the system.
 *
 * @author Matheus Borges Teixeira
 * @param variable - variable to be purged
 */
void purge_variable(data ** variable){
	if((*variable) != NULL && (*variable) -> name[0] == '_'){
		free((*variable) -> name);
		free((*variable) -> content);
		free((*variable));
		*variable = NULL;
	}	
}

/**
 * Converts a variable to a new type.
 * Nothing is done if types match.
 *
 * @author Matheus Borges Teixeira
 * @param old - variable to be converted
 * @param type - type which is requested to convert to
 * @return a new variable with the converted value
 */
data * convert_variable(data * old, int type){
	data * temporary;
	char * auxiliary;
	temporary = (data*)malloc(sizeof(data));
	temporary -> name = (char*)malloc(sizeof(char)*MAXLENGTH+1);
	sprintf(temporary -> name,"_converted%d",given_conversions_count++);
	temporary -> type = type;
	temporary -> isExtern = 0;
	switch(type){
		case TYPESTRING: 
			/* No relocations, redirecting pointers */
			switch(old -> type){
				case TYPESTRING:
					free(temporary -> name);
					free(temporary);
					return old;  
				case TYPEINT:
					auxiliary = (char*)malloc((MAXLENGTH+1)*sizeof(char));
					sprintf(auxiliary,"%ld",*(DECLAREINT*)(old -> content));
					temporary -> content = auxiliary;
					return temporary;
				case TYPEFLOAT:
					auxiliary = (char*)malloc((MAXLENGTH+1)*sizeof(char));
					sprintf(auxiliary,"%g",*(DECLAREFLOAT*)(old -> content));
					temporary -> content = auxiliary;
					return temporary;
			}
			break;
		case TYPEINT:
			temporary -> content = malloc(sizeof(DECLAREINT));
			switch(old -> type){
				case TYPESTRING:
					*(DECLAREINT*)(temporary -> content) = (DECLAREINT)atoi((DECLARESTRING)old -> content);
					return temporary;
				case TYPEINT:
					free(temporary -> content);
					free(temporary -> name);
					free(temporary);
					return old;
				case TYPEFLOAT:		   
					*(DECLAREINT*)(temporary -> content) = (DECLAREINT)(*(DECLAREFLOAT*)(old -> content));
					return temporary;
			}
			break;
		case TYPEFLOAT:
			temporary -> content = malloc(sizeof(DECLAREFLOAT));
			switch(old -> type){
				case TYPESTRING:
					/* TODO: treat conversion errors nicely */
					*((DECLAREFLOAT*)(temporary -> content)) =  (DECLAREFLOAT)strtof((DECLARESTRING)old -> content,NULL);
					break;
				case TYPEINT:
					*(DECLAREFLOAT*)(temporary -> content) = (DECLAREFLOAT)(*(DECLAREINT*)(old -> content));
					return temporary;
				case TYPEFLOAT:
					free(temporary -> content);
					free(temporary -> name);
					free(temporary);
					return old;
			}
			break;
		default:
			interpreterError(ILLEGALTYPE,"Could not make type conversion.");
	}
	interpreterError(UNKNOWN,"Illegal state, could not make type conversion.");
}

/**
 * Creates a variable with the value 0.
 *
 * @author Matheus Borges Teixeira
 * @return variable with content 0
 */
data * create_zero(void){
	data * new_zero = (data*)malloc(sizeof(data));
	char * auxiliary = (char*)malloc(sizeof(char)*NAMEOFTHINGS+1);
	sprintf(auxiliary,"_zero%d",given_zeros_count++);
	new_zero -> name = auxiliary;
	new_zero -> isExtern = 0; 
	new_zero -> type = TYPEINT;
	new_zero -> content = malloc(sizeof(DECLAREINT));
	*((DECLAREINT*)new_zero -> content) = (int)0;
	#ifdef __DEBUG__MODE__
	printf("Created a zero %s for line %d\n",new_zero -> name,line);
	#endif
	return new_zero;
}

/**
 * Replaces (*<VARIABLE>) and $<VARIABLE> in a string by variable contents.
 *
 * @author Matheus Borges Teixeira
 * @param original - string to be replaced
 * @return string with contents replaced
 */
char * replace_variables(char * original){
	int i = 0;
	int k = 0;
	int start = 0;
	int end = -1;
	int size = strlen(original);
	data * variable = NULL;
	char * variable_name = NULL;
	char * replaced = NULL;
	data * temporary = NULL;
	char * auxiliary = NULL;
	while(original[i] != '\0'){ 
		if(original[i] == '\\'){
			i += 1;
		}
		else{
			if(original[i] == '('){
				if(original[++i] == '*'){
					size -= 3;
					k = i + 1;
					start = i;
					while(original[k] != ')'){
						if(original[k] == '\n'){
							interpreterError(UNEXPECTEDLINEEND,"Line ended while replacing variables, ')' missing.");
						}
						k += 1;
					}
					end = k;
					variable_name = (char*)malloc((end-start+1-1)*sizeof(char));
					variable_name[0] = '\0';
					strncat(variable_name,&original[start+1],end-start+1-2);
					break;					
				}
			}
			if(original[i] == '$'){
				size -= 1;
				k = i + 1;
				start = i + 1;
				while(allowed_identifier_char(original[k])){
					k += 1;
				}
				end = k - 1;
				variable_name = (char*)malloc((end-start+1+1)*sizeof(char));
				variable_name[0] = '\0';
				strncat(variable_name,&original[start],end-start+1);
				break;
			}
		}
		i += 1;
	}
	if(start <= end){
		variable = get_variable(variable_name);
		free(variable_name);
		temporary = convert_variable(variable,TYPESTRING);

		size += strlen((char*)temporary -> content);

		replaced = (char*)malloc((size+1)*sizeof(char));
		replaced[0] = '\0';
		
		strncat(replaced,original,start-1);
		strcat(replaced,(char*)temporary -> content);
		strncat(replaced,&original[end+1],strlen(original)-end);

		purge_variable(&temporary);
		auxiliary = replace_variables(replaced);
		free(replaced);
		return auxiliary;
	}
	else{
		replaced = (char*)malloc((size+1)*sizeof(char));
		replaced[0] = '\0';
		strcpy(replaced,original);
		return replaced;
	}

}

/**
 * Releases the memory for all persistent variables.
 *
 * @author Matheus Borges Teixeira
 */
void flush_variables(void){
	datalist * node = beginning;
	datalist * p_node = NULL;
	#ifdef __DEBUG__MODE__
	printf("Flushing variables\n");
	#endif
	while(node != NULL){
		free(node -> variable -> name);
		free(node -> variable -> content);
		free(node -> variable);
		p_node = node;
		node = node -> next;
		free(p_node);
	}
	#ifdef __DEBUG__MODE__
	printf("Flushed variables\n");
	#endif
}

/**
 * Consults the external environment if a particular variable exists.
 * FIXME empty!
 * @author Matheus Borges Teixeira
 * @param name - name of the external variable
 * @return 1 for yes or 0 for no
 */
char check_extern(char * name){
	/* TODO: implement this check */
	/*All variables are not available externally*/
	return 0;
}

/**
 * Retrieves the value of an external variable.
 * FIXME empty!
 * @author Matheus Borges Teixeira
 * @param value - variable to be updated
 */
void refresh_extern(data * value){
	/* TODO: implement this retrieval */
	/* Nothing is done */
	return;	 
}

/**
 * Exports the value of an external variable.
 * FIXME empty!
 * @author Matheus Borges Teixeira
 * @param value - variable to be exported
 */
void update_extern(data * modified){
	/* TODO: implement this update */
	/* Nothing is done */
	return;
}
